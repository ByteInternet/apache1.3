--- build-tree-apache/apache_1.3.41/src/main/http_main.c	2007-12-23 21:22:36.966308407 +0100
+++ build-tree-apache/apache_1.3.41/src/main/http_main.c	2007-12-23 21:17:05.574907963 +0100
@@ -354,9 +354,17 @@
 char tpf_mutex_key[TPF_MUTEX_KEY_SIZE];
 #endif /* TPF */
 
+/*
+ * Shared memory scoreboard
+ */
 scoreboard *ap_scoreboard_image = NULL;
 
 /*
+ * Parent process local storage of child pids
+ */
+static int pid_table[HARD_SERVER_LIMIT];
+
+/*
  * Pieces for managing the contents of the Server response header
  * field.
  */
@@ -372,6 +380,41 @@
 API_VAR_EXPORT int ap_change_shmem_uid = 0;
 
 /*
+ * Check the pid table to see if the actual pid exists
+ */
+
+static int in_pid_table(int pid) {
+    int i;
+    for (i = 0; i < HARD_SERVER_LIMIT; i++) {
+        if (pid_table[i] == pid) {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+static void set_pid_table(int pid) {
+    int i;
+    for (i = 0; i < HARD_SERVER_LIMIT; i++) {
+        if (pid_table[i] == 0) {
+            pid_table[i] = pid;
+            break;
+        }
+    }
+    /* NOTE: Error detection?? */
+}
+
+static void unset_pid_table(int pid) {
+    int i;
+    for (i = 0; i < HARD_SERVER_LIMIT; i++) {
+        if (pid_table[i] == pid) {
+            pid_table[i] = 0;
+            break;
+        }
+    }
+}
+
+/*
  * This routine is called when the pconf pool is vacuumed.  It resets the
  * server version string to a known value and [re]enables modifications
  * (which are disabled by configuration completion). 
@@ -2645,7 +2688,10 @@
 	    ss->vhostrec =  r->server;
 	}
     }
-    if (status == SERVER_STARTING && r == NULL) {
+    if (status == SERVER_DEAD) {
+        ap_scoreboard_image->parent[child_num].pid = 0;
+    }
+    else if (status == SERVER_STARTING && r == NULL) {
 	/* clean up the slot's vhostrec pointer (maybe re-used)
 	 * and mark the slot as belonging to a new generation.
 	 */
@@ -2787,9 +2833,15 @@
 	    if (pid == my_pid || pid == 0)
 		continue;
 
+            if (!in_pid_table(pid)) {
+                ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
+                             "Bad pid (%d) in scoreboard slot %d", pid, i);
+                continue;
+            }
 	    waitret = waitpid(pid, &status, WNOHANG);
 	    if (waitret == pid || waitret == -1) {
 		ap_scoreboard_image->parent[i].pid = 0;
+                unset_pid_table(pid);
 		continue;
 	    }
 	    ++not_dead_yet;
@@ -2887,13 +2939,22 @@
 
     for (n = 0; n < max_daemons_limit; ++n) {
         ap_sync_scoreboard_image();
-	if (ap_scoreboard_image->servers[n].status != SERVER_DEAD &&
-		kill((pid = ap_scoreboard_image->parent[n].pid), 0) == -1) {
-	    ap_update_child_status(n, SERVER_DEAD, NULL);
-	    /* just mark it as having a successful exit status */
-	    bzero((char *) status, sizeof(ap_wait_t));
-	    return(pid);
-	}
+        pid = ap_scoreboard_image->parent[n].pid;
+        if (ap_scoreboard_image->servers[n].status != SERVER_DEAD) {
+            if (in_pid_table(pid)) {
+                if (kill(pid, 0) == -1) {
+                    ap_update_child_status(n, SERVER_DEAD, NULL);
+                    /* just mark it as having a successful exit status */
+                    bzero((char *) status, sizeof(ap_wait_t));
+                    unset_pid_table(pid);       /* to be safe */
+                    return(pid);
+                }
+            }
+            else {
+                ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
+                            "Bad pid (%d) in scoreboard slot %d", pid, n);
+            }
+        }
     }
     return 0;
 }
@@ -2916,15 +2977,21 @@
 #define MAXWAITOBJ MAXIMUM_WAIT_OBJECTS
     HANDLE h[MAXWAITOBJ];
     int e[MAXWAITOBJ];
-    int round, pi, hi, rv, err;
+    int round, pi, hi, rv, err, pid;
     for (round = 0; round <= (HARD_SERVER_LIMIT - 1) / MAXWAITOBJ + 1; round++) {
 	hi = 0;
 	for (pi = round * MAXWAITOBJ;
 	     (pi < (round + 1) * MAXWAITOBJ) && (pi < HARD_SERVER_LIMIT);
 	     pi++) {
 	    if (ap_scoreboard_image->servers[pi].status != SERVER_DEAD) {
-		e[hi] = pi;
-		h[hi++] = (HANDLE) ap_scoreboard_image->parent[pi].pid;
+                e[hi] = pi;
+                pid = ap_scoreboard_image->parent[pi].pid;
+                if (in_pid_table(pid))
+                    h[hi++] = (HANDLE) pid;
+                else {
+                    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
+                                 "Bad pid (%d) in scoreboard slot %d", pid, pi);
+                }
 	    }
 
 	}
@@ -4314,6 +4381,7 @@
  */
 static void common_init(void)
 {
+    int i;
     INIT_SIGLIST()
 #ifdef AUX3
     (void) set42sig();
@@ -4339,6 +4407,10 @@
     ap_server_pre_read_config  = ap_make_array(pcommands, 1, sizeof(char *));
     ap_server_post_read_config = ap_make_array(pcommands, 1, sizeof(char *));
     ap_server_config_defines   = ap_make_array(pcommands, 1, sizeof(char *));
+    /* overkill since static */
+    for (i = 0; i < HARD_SERVER_LIMIT; i++) {
+        pid_table[i] = 0;
+    }
 }
 
 #ifndef MULTITHREAD
@@ -4987,6 +5059,7 @@
     ap_scoreboard_image->parent[slot].last_rtime = now;
 #endif
     ap_scoreboard_image->parent[slot].pid = pid;
+    set_pid_table(pid);
 #ifdef SCOREBOARD_FILE
     lseek(scoreboard_fd, XtOffsetOf(scoreboard, parent[slot]), 0);
     force_write(scoreboard_fd, &ap_scoreboard_image->parent[slot],
@@ -5049,6 +5122,7 @@
     int i;
     int to_kill;
     int idle_count;
+    int pid;
     short_score *ss;
     time_t now = time(NULL);
     int free_length;
@@ -5113,8 +5187,15 @@
 		else if (ps->last_rtime + ss->timeout_len < now) {
 		    /* no progress, and the timeout length has been exceeded */
 		    ss->timeout_len = 0;
-		    kill(ps->pid, SIG_TIMEOUT_KILL);
-		}
+                    pid = ps->pid;
+                    if (in_pid_table(pid)) {
+                        kill(pid, SIG_TIMEOUT_KILL);
+                    }
+                    else {
+                        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
+                            "Bad pid (%d) in scoreboard slot %d", pid, i);
+                    }
+                }
 	    }
 #endif
 	}
@@ -5126,11 +5207,18 @@
 	 * while we were counting. Use the define SIG_IDLE_KILL to reflect
 	 * which signal should be used on the specific OS.
 	 */
-	kill(ap_scoreboard_image->parent[to_kill].pid, SIG_IDLE_KILL);
-	idle_spawn_rate = 1;
+        pid = ap_scoreboard_image->parent[to_kill].pid;
+        if (in_pid_table(pid)) {
+            kill(pid, SIG_IDLE_KILL);
+            idle_spawn_rate = 1;
 #ifdef TPF
-        ap_update_child_status(to_kill, SERVER_DEAD, (request_rec *)NULL);
+            ap_update_child_status(to_kill, SERVER_DEAD, (request_rec *)NULL);
 #endif
+        }
+        else {
+            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
+                         "Bad pid (%d) in scoreboard slot %d", pid, to_kill);
+        }
     }
     else if (idle_count < ap_daemons_min_free) {
 	/* terminate the free list */
@@ -5377,6 +5465,7 @@
             }
 #endif
 	    if (pid >= 0) {
+		unset_pid_table(pid);
 		process_child_status(pid, status);
 		/* non-fatal death... note that it's gone in the scoreboard. */
 		ap_sync_scoreboard_image();
--- build-tree-apache/pkg.eapi/eapi.patch	2007-12-27 12:55:23.000000000 +0100
+++ /tmp/eapi.patch	2007-12-27 12:48:22.756702318 +0100
@@ -1271,9 +1271,9 @@
 +
 +    ap_global_ctx = ap_ctx_new(NULL);
 +#endif /* EAPI */
- }
- 
- #ifndef MULTITHREAD
+     /* overkill since static */
+     for (i = 0; i < HARD_SERVER_LIMIT; i++) {
+         pid_table[i] = 0;
 @@ -4809,6 +4894,9 @@
  
  	    ap_sync_scoreboard_image();
